PageCacheManager is designed to speed up access to content views while
at the same time making sure that stale content is not served up.

Installation:

PageCacheManager is designed specifically for caching views of content
objects.  Unlike RAMCacheManager, PageCacheManager caches both the
html generated by a view as well as the HTTP headers.

PageCacheManager builds upon Zope's standard cache manager machinery.  
As with RAMCacheManager, you associate some page templates with the cache 
manager and configure the properties.  PageCacheManager requires an
extra step: content to be cached must generate an ETag via a caching
policy.  PageCacheManager looks for a CachingPolicyManager with id
caching_policy_manager.  If it finds it, it then gets an ETag for the
current template + content object combination.  This ETag is then used
as the index into the cache.  If you don't have an ETag generated for
your content, your pages will not be cached.

If you create an ETag that changes when the content is changed, then
the content served up by the cache will stay fresh.  There will be a 
cache miss the first time the page is hit after the ETag changes, then
subsequent hits to the newly modified content view will reflect the new
version.  If your content view is personalized, you will want your ETag
to vary depending on the current user.  A good ETag with these properties
is as follows:

ETag = id of currently authenticated user + delimiter + last modified time
  for content + delimiter + current time rounded to the nearest hour

The use of the id in the ETag means that every user's view of a content
object will have a different ETag, so everybody will get different
cached objects.  The use of the modification time means that every time
the content object changes, it will generate different ETags and hence
will result in new copies being pulled from the cache.  The use of
the current time rounded to the nearest hour means that nothing will be
served up by the cache for more than an hour.

Added bonus: PageCacheManager handles conditional GETs.  If the incoming
request has an If-Modified-Since header with an ETag that matches the
content object's current ETag, PageCacheManager will set a status 304
header (Not Modified) and will return no content.

To do:

* Test, test, test
* Need to make sure cache invalidation and clean up works properly


Author:

Geoff Davis
geoff at geoffdavis dot net

